name: Cron Pipeline

on:
  schedule:
    - cron: "*/15 * * * *"
  workflow_dispatch:
    inputs:
      mode:
        description: "process_only | ingest_then_process | ingest_only"
        required: false
        default: "process_only"
        type: choice
        options:
          - process_only
          - ingest_then_process
          - ingest_only
      process_step:
        description: "Step for process run"
        required: false
        default: "all"
        type: choice
        options:
          - all
          - embedding
          - clustering
          - scoring
          - rewriting
      max_execution_ms:
        description: "Override process max execution in ms"
        required: false
        default: "1080000"
        type: string
      stage_max_execution_ms:
        description: "Per-step max execution in ms for ingest_then_process"
        required: false
        default: "480000"
        type: string
      max_cycles_per_step:
        description: "Max process cycles per step for ingest_then_process"
        required: false
        default: "6"
        type: string

concurrency:
  group: cron-pipeline
  cancel-in-progress: false

jobs:
  pipeline:
    runs-on: ubuntu-latest
    environment: Production
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Cache node_modules
        id: cache-node-modules
        uses: actions/cache@v4
        with:
          path: node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('package-lock.json') }}

      - name: Install Dependencies
        if: steps.cache-node-modules.outputs.cache-hit != 'true'
        run: npm ci

      - name: Resolve Mode
        id: mode
        env:
          EVENT_NAME: ${{ github.event_name }}
          INPUT_MODE: ${{ github.event.inputs.mode }}
        run: |
          set -euo pipefail
          mode="ingest_then_process"
          if [ "${EVENT_NAME}" = "workflow_dispatch" ] && [ -n "${INPUT_MODE:-}" ]; then
            mode="${INPUT_MODE}"
          fi
          echo "mode=${mode}" >> "$GITHUB_OUTPUT"
          echo "Resolved mode: ${mode}"

      - name: Run Ingest
        id: ingest
        if: steps.mode.outputs.mode == 'ingest_then_process' || steps.mode.outputs.mode == 'ingest_only'
        run: |
          set -euo pipefail
          output="$(npm run -s cron:ingest)"
          echo "${output}"
          json_line="$(printf '%s\n' "${output}" | sed -n 's/.*__CRON_JSON__//p' | tail -n 1)"
          if [ -z "${json_line}" ]; then
            json_line="$(printf '%s\n' "${output}" | sed -n '/^[[:space:]]*{.*}[[:space:]]*$/p' | tail -n 1)"
          fi
          if [ -z "${json_line}" ]; then
            articles_ingested="unknown"
          else
            articles_ingested="$(node -e 'const raw = process.argv[1] || ""; let value = 0; try { const data = JSON.parse(raw); value = Number(data?.articlesIngested ?? 0); if (!Number.isFinite(value)) value = 0; } catch {} process.stdout.write(String(Math.max(0, Math.trunc(value))));' "${json_line}")"
          fi
          echo "articles_ingested=${articles_ingested}" >> "$GITHUB_OUTPUT"
          echo "Ingested articles: ${articles_ingested}"
        env:
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          EXECUTION_PROFILE: manual

      - name: Precheck Backlog (process_only)
        id: precheck
        if: steps.mode.outputs.mode == 'process_only'
        run: |
          set -euo pipefail
          output="$(npm run -s cron:should-process)"
          echo "${output}"
          json_line="$(printf '%s\n' "${output}" | sed -n 's/.*__CRON_JSON__//p' | tail -n 1)"
          if [ -z "${json_line}" ]; then
            json_line="$(printf '%s\n' "${output}" | sed -n '/^[[:space:]]*{.*}[[:space:]]*$/p' | tail -n 1)"
          fi
          should_process="$(node -e 'const raw = process.argv[1] || ""; let value = true; try { const data = JSON.parse(raw); value = !!data?.shouldProcess; } catch {} process.stdout.write(value ? "true" : "false");' "${json_line}")"
          reason="$(node -e 'const raw = process.argv[1] || ""; let value = "precheck_parse_fallback"; try { const data = JSON.parse(raw); const reasons = Array.isArray(data?.reasons) ? data.reasons.join(",") : ""; value = reasons || "no_backlog"; } catch {} process.stdout.write(value);' "${json_line}")"
          echo "should_process=${should_process}" >> "$GITHUB_OUTPUT"
          echo "reason=${reason}" >> "$GITHUB_OUTPUT"
          echo "Precheck: should_process=${should_process} (${reason})"
        env:
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}

      - name: Decide Process Run
        id: decide
        env:
          MODE: ${{ steps.mode.outputs.mode }}
          INGESTED: ${{ steps.ingest.outputs.articles_ingested }}
          PRECHECK_SHOULD: ${{ steps.precheck.outputs.should_process }}
          PRECHECK_REASON: ${{ steps.precheck.outputs.reason }}
        run: |
          set -euo pipefail
          should_process="true"
          reason="scheduled process tick"

          if [ "${MODE}" = "ingest_only" ]; then
            should_process="false"
            reason="ingest-only mode"
          elif [ "${MODE}" = "process_only" ]; then
            precheck_should="${PRECHECK_SHOULD:-true}"
            precheck_reason="${PRECHECK_REASON:-precheck_missing}"
            if [ "${precheck_should}" = "true" ]; then
              should_process="true"
              reason="precheck backlog: ${precheck_reason}"
            else
              should_process="false"
              reason="precheck no backlog: ${precheck_reason}"
            fi
          elif [ "${MODE}" = "ingest_then_process" ]; then
            ingested="${INGESTED:-0}"
            if ! [[ "${ingested}" =~ ^[0-9]+$ ]]; then
              should_process="true"
              reason="ingest parse fallback"
              echo "should_process=${should_process}" >> "$GITHUB_OUTPUT"
              echo "reason=${reason}" >> "$GITHUB_OUTPUT"
              echo "Decision: should_process=${should_process} (${reason})"
              exit 0
            fi
            if [ "${ingested}" -gt 0 ]; then
              should_process="true"
              reason="ingest added ${ingested} articles"
            else
              should_process="false"
              reason="ingest added 0 article"
            fi
          fi

          echo "should_process=${should_process}" >> "$GITHUB_OUTPUT"
          echo "reason=${reason}" >> "$GITHUB_OUTPUT"
          echo "Decision: should_process=${should_process} (${reason})"

      - name: Run Process (process_only)
        if: steps.decide.outputs.should_process == 'true' && steps.mode.outputs.mode == 'process_only'
        run: |
          set -euo pipefail
          output="$(QUIET_LOGS=1 npm run -s cron:process)"
          echo "${output}"
        env:
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
          PAID_OPENAI_API_KEY: ${{ secrets.PAID_OPENAI_API_KEY }}
          PAID_ANTHROPIC_API_KEY: ${{ secrets.PAID_ANTHROPIC_API_KEY }}
          PAID_GOOGLE_API_KEY: ${{ secrets.PAID_GOOGLE_API_KEY }}
          PROCESS_STEP: ${{ github.event.inputs.process_step || 'all' }}
          MAX_EXECUTION_MS: ${{ github.event.inputs.max_execution_ms || '1080000' }}
      - name: Run Process By Step (ingest_then_process)
        if: steps.decide.outputs.should_process == 'true' && steps.mode.outputs.mode == 'ingest_then_process'
        run: |
          set -euo pipefail
          per_step_max_ms="${PER_STEP_MAX_EXECUTION_MS:-240000}"
          max_cycles_per_step="${MAX_CYCLES_PER_STEP:-4}"

          if ! [[ "${per_step_max_ms}" =~ ^[0-9]+$ ]]; then
            per_step_max_ms="240000"
          fi
          if ! [[ "${max_cycles_per_step}" =~ ^[0-9]+$ ]]; then
            max_cycles_per_step="4"
          fi

          for step in embedding clustering scoring rewriting; do
            echo "== Drain step: ${step} (max_cycles=${max_cycles_per_step}, max_ms=${per_step_max_ms}) =="
            cycle=1
            while [ "${cycle}" -le "${max_cycles_per_step}" ]; do
              output="$(QUIET_LOGS=1 PROCESS_STEP="${step}" MAX_EXECUTION_MS="${per_step_max_ms}" npm run -s cron:process)"
              echo "${output}"
              json_line="$(printf '%s\n' "${output}" | sed -n 's/.*__CRON_JSON__//p' | tail -n 1)"
              if [ -z "${json_line}" ]; then
                json_line="$(printf '%s\n' "${output}" | sed -n '/^[[:space:]]*{.*}[[:space:]]*$/p' | tail -n 1)"
              fi

              processed="$(node -e 'const step = process.argv[1]; const raw = process.argv[2] || ""; let value = 0; try { const data = JSON.parse(raw); const statKey = step === "embedding" ? "embeddings" : step === "clustering" ? "clustered" : step === "scoring" ? "scored" : step === "rewriting" ? "rewritten" : step; value = Number(data?.processed?.[statKey] ?? 0); if (!Number.isFinite(value)) value = 0; } catch {} process.stdout.write(String(Math.max(0, Math.trunc(value))));' "${step}" "${json_line}")"
              stopped="$(node -e 'const raw = process.argv[1] || ""; let value = false; try { const data = JSON.parse(raw); value = !!data?.processed?.stopped; } catch {} process.stdout.write(value ? "true" : "false");' "${json_line}")"
              retry_after="$(node -e 'const raw = process.argv[1] || ""; let value = 0; try { const data = JSON.parse(raw); value = Number(data?.retryAfter ?? 0); if (!Number.isFinite(value)) value = 0; } catch {} process.stdout.write(String(Math.max(0, Math.trunc(value))));' "${json_line}")"
              success="$(node -e 'const raw = process.argv[1] || ""; let value = false; try { const data = JSON.parse(raw); value = !!data?.success; } catch {} process.stdout.write(value ? "true" : "false");' "${json_line}")"

              echo "Step ${step} cycle ${cycle}: processed=${processed} stopped=${stopped} success=${success} retryAfter=${retry_after}"

              if [ "${stopped}" = "true" ]; then
                echo "Server stop requested. Ending staged process run."
                exit 0
              fi

              if ! [[ "${processed}" =~ ^[0-9]+$ ]]; then
                processed="0"
              fi

              if [ "${success}" != "true" ] && [[ "${retry_after}" =~ ^[0-9]+$ ]] && [ "${retry_after}" -gt 0 ]; then
                echo "Rate limit detected on step ${step}. Sleeping ${retry_after}s before retry."
                sleep "${retry_after}"
                cycle=$((cycle + 1))
                continue
              fi

              if [ "${processed}" -eq 0 ]; then
                echo "Step ${step} drained."
                break
              fi

              cycle=$((cycle + 1))
            done
          done
        env:
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
          PAID_OPENAI_API_KEY: ${{ secrets.PAID_OPENAI_API_KEY }}
          PAID_ANTHROPIC_API_KEY: ${{ secrets.PAID_ANTHROPIC_API_KEY }}
          PAID_GOOGLE_API_KEY: ${{ secrets.PAID_GOOGLE_API_KEY }}
          PROCESS_STEP: ${{ github.event.inputs.process_step || 'all' }}
          MAX_EXECUTION_MS: ${{ github.event.inputs.max_execution_ms || '1080000' }}
          PER_STEP_MAX_EXECUTION_MS: ${{ github.event.inputs.stage_max_execution_ms || '480000' }}
          MAX_CYCLES_PER_STEP: ${{ github.event.inputs.max_cycles_per_step || '6' }}
