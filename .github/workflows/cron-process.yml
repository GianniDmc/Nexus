name: Cron Pipeline

on:
  schedule:
    - cron: "*/15 * * * *"
  workflow_dispatch:
    inputs:
      mode:
        description: "process_only | ingest_then_process | ingest_only"
        required: false
        default: "process_only"
        type: choice
        options:
          - process_only
          - ingest_then_process
          - ingest_only
      process_step:
        description: "Step for process run"
        required: false
        default: "all"
        type: choice
        options:
          - all
          - embedding
          - clustering
          - scoring
          - rewriting
      max_execution_ms:
        description: "Override global process max execution in ms (default 24 min)"
        required: false
        default: "1440000"
        type: string

concurrency:
  group: cron-pipeline
  cancel-in-progress: false

jobs:
  pipeline:
    runs-on: ubuntu-latest
    environment: Production
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Cache node_modules
        id: cache-node-modules
        uses: actions/cache@v4
        with:
          path: node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('package-lock.json') }}

      - name: Install Dependencies
        if: steps.cache-node-modules.outputs.cache-hit != 'true'
        run: npm ci

      - name: Resolve Mode
        id: mode
        env:
          EVENT_NAME: ${{ github.event_name }}
          INPUT_MODE: ${{ github.event.inputs.mode }}
        run: |
          set -euo pipefail
          mode="ingest_then_process"
          if [ "${EVENT_NAME}" = "workflow_dispatch" ] && [ -n "${INPUT_MODE:-}" ]; then
            mode="${INPUT_MODE}"
          fi
          echo "mode=${mode}" >> "$GITHUB_OUTPUT"
          echo "Resolved mode: ${mode}"

      - name: Run Ingest
        id: ingest
        if: steps.mode.outputs.mode == 'ingest_then_process' || steps.mode.outputs.mode == 'ingest_only'
        run: |
          set -euo pipefail
          output="$(npm run -s cron:ingest)"
          echo "${output}"
          json_line="$(printf '%s\n' "${output}" | sed -n 's/.*__CRON_JSON__//p' | tail -n 1)"
          if [ -z "${json_line}" ]; then
            json_line="$(printf '%s\n' "${output}" | sed -n '/^[[:space:]]*{.*}[[:space:]]*$/p' | tail -n 1)"
          fi
          if [ -z "${json_line}" ]; then
            articles_ingested="unknown"
          else
            articles_ingested="$(node -e 'const raw = process.argv[1] || ""; let value = 0; try { const data = JSON.parse(raw); value = Number(data?.articlesIngested ?? 0); if (!Number.isFinite(value)) value = 0; } catch {} process.stdout.write(String(Math.max(0, Math.trunc(value))));' "${json_line}")"
          fi
          echo "articles_ingested=${articles_ingested}" >> "$GITHUB_OUTPUT"
          echo "Ingested articles: ${articles_ingested}"
        env:
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          EXECUTION_PROFILE: manual

      - name: Precheck Backlog (process_only)
        id: precheck
        if: steps.mode.outputs.mode == 'process_only'
        run: |
          set -euo pipefail
          output="$(npm run -s cron:should-process)"
          echo "${output}"
          json_line="$(printf '%s\n' "${output}" | sed -n 's/.*__CRON_JSON__//p' | tail -n 1)"
          if [ -z "${json_line}" ]; then
            json_line="$(printf '%s\n' "${output}" | sed -n '/^[[:space:]]*{.*}[[:space:]]*$/p' | tail -n 1)"
          fi
          should_process="$(node -e 'const raw = process.argv[1] || ""; let value = true; try { const data = JSON.parse(raw); value = !!data?.shouldProcess; } catch {} process.stdout.write(value ? "true" : "false");' "${json_line}")"
          reason="$(node -e 'const raw = process.argv[1] || ""; let value = "precheck_parse_fallback"; try { const data = JSON.parse(raw); const reasons = Array.isArray(data?.reasons) ? data.reasons.join(",") : ""; value = reasons || "no_backlog"; } catch {} process.stdout.write(value);' "${json_line}")"
          echo "should_process=${should_process}" >> "$GITHUB_OUTPUT"
          echo "reason=${reason}" >> "$GITHUB_OUTPUT"
          echo "Precheck: should_process=${should_process} (${reason})"
        env:
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}

      - name: Decide Process Run
        id: decide
        env:
          MODE: ${{ steps.mode.outputs.mode }}
          INGESTED: ${{ steps.ingest.outputs.articles_ingested }}
          PRECHECK_SHOULD: ${{ steps.precheck.outputs.should_process }}
          PRECHECK_REASON: ${{ steps.precheck.outputs.reason }}
        run: |
          set -euo pipefail
          should_process="true"
          reason="scheduled process tick"

          if [ "${MODE}" = "ingest_only" ]; then
            should_process="false"
            reason="ingest-only mode"
          elif [ "${MODE}" = "process_only" ]; then
            precheck_should="${PRECHECK_SHOULD:-true}"
            precheck_reason="${PRECHECK_REASON:-precheck_missing}"
            if [ "${precheck_should}" = "true" ]; then
              should_process="true"
              reason="precheck backlog: ${precheck_reason}"
            else
              should_process="false"
              reason="precheck no backlog: ${precheck_reason}"
            fi
          elif [ "${MODE}" = "ingest_then_process" ]; then
            ingested="${INGESTED:-0}"
            if ! [[ "${ingested}" =~ ^[0-9]+$ ]]; then
              should_process="true"
              reason="ingest parse fallback"
              echo "should_process=${should_process}" >> "$GITHUB_OUTPUT"
              echo "reason=${reason}" >> "$GITHUB_OUTPUT"
              echo "Decision: should_process=${should_process} (${reason})"
              exit 0
            fi
            if [ "${ingested}" -gt 0 ]; then
              should_process="true"
              reason="ingest added ${ingested} articles"
            else
              should_process="false"
              reason="ingest added 0 article"
            fi
          fi

          echo "should_process=${should_process}" >> "$GITHUB_OUTPUT"
          echo "reason=${reason}" >> "$GITHUB_OUTPUT"
          echo "Decision: should_process=${should_process} (${reason})"

      - name: Run Process (process_only)
        if: steps.decide.outputs.should_process == 'true' && steps.mode.outputs.mode == 'process_only'
        run: |
          set -euo pipefail
          output="$(QUIET_LOGS=1 npm run -s cron:process)"
          echo "${output}"
        env:
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
          PAID_OPENAI_API_KEY: ${{ secrets.PAID_OPENAI_API_KEY }}
          PAID_ANTHROPIC_API_KEY: ${{ secrets.PAID_ANTHROPIC_API_KEY }}
          PAID_GOOGLE_API_KEY: ${{ secrets.PAID_GOOGLE_API_KEY }}
          PROCESS_STEP: ${{ github.event.inputs.process_step || 'all' }}
          MAX_EXECUTION_MS: ${{ github.event.inputs.max_execution_ms || '1080000' }}
      - name: Run Process By Step (ingest_then_process)
        if: steps.decide.outputs.should_process == 'true' && steps.mode.outputs.mode == 'ingest_then_process'
        run: |
          set -euo pipefail
          MAX_GLOBAL_MS="${MAX_EXECUTION_MS:-1440000}" 
          GLOBAL_START_TIME=$(date +%s)
          can_continue="true"

          for step in embedding clustering scoring rewriting; do
            if [ "${can_continue}" = "false" ]; then
              echo "== Skipping step: ${step} (prior step did not fully drain) =="
              continue
            fi

            now=$(date +%s)
            elapsed_sec=$((now - GLOBAL_START_TIME))
            remaining_sec=$((MAX_GLOBAL_MS / 1000 - elapsed_sec))

            if [ "$remaining_sec" -le 0 ]; then
              echo "Global time budget reached. Stopping GHA gracefully."
              exit 0
            fi

            computed_ms=$((remaining_sec * 1000))
            echo "== Processing step: ${step} (remaining time budget: ${remaining_sec}s) =="

            output="$(QUIET_LOGS=1 PROCESS_STEP="${step}" MAX_EXECUTION_MS="${computed_ms}" npm run -s cron:process)"
            echo "${output}"
            json_line="$(printf '%s\n' "${output}" | sed -n 's/.*__CRON_JSON__//p' | tail -n 1)"
            if [ -z "${json_line}" ]; then
              json_line="$(printf '%s\n' "${output}" | sed -n '/^[[:space:]]*{.*}[[:space:]]*$/p' | tail -n 1)"
            fi

            processed="$(node -e 'const step = process.argv[1]; const raw = process.argv[2] || ""; let value = 0; try { const data = JSON.parse(raw); const statKey = step === "embedding" ? "embeddings" : step === "clustering" ? "clustered" : step === "scoring" ? "scored" : step === "rewriting" ? "rewritten" : step; value = Number(data?.processed?.[statKey] ?? 0); if (!Number.isFinite(value)) value = 0; } catch {} process.stdout.write(String(Math.max(0, Math.trunc(value))));' "${step}" "${json_line}")"
            stopped="$(node -e 'const raw = process.argv[1] || ""; let value = false; try { const data = JSON.parse(raw); value = !!data?.processed?.stopped; } catch {} process.stdout.write(value ? "true" : "false");' "${json_line}")"
            retry_after="$(node -e 'const raw = process.argv[1] || ""; let value = 0; try { const data = JSON.parse(raw); value = Number(data?.retryAfter ?? 0); if (!Number.isFinite(value)) value = 0; } catch {} process.stdout.write(String(Math.max(0, Math.trunc(value))));' "${json_line}")"
            success="$(node -e 'const raw = process.argv[1] || ""; let value = false; try { const data = JSON.parse(raw); value = !!data?.success; } catch {} process.stdout.write(value ? "true" : "false");' "${json_line}")"
            elapsed_ms="$(node -e 'const raw = process.argv[1] || ""; let value = 0; try { const data = JSON.parse(raw); value = Number(data?.elapsedMs ?? 0); if (!Number.isFinite(value)) value = 0; } catch {} process.stdout.write(String(Math.max(0, Math.trunc(value))));' "${json_line}")"
            elapsed_sec="$(node -e 'process.stdout.write((Number(process.argv[1]) / 1000).toFixed(1));' "${elapsed_ms}")"
            time_budget_reached="$(node -e 'const raw = process.argv[1] || ""; let value = false; try { const data = JSON.parse(raw); value = !!data?.timeBudgetReached; } catch {} process.stdout.write(value ? "true" : "false");' "${json_line}")"

            echo "Step ${step}: processed=${processed} stopped=${stopped} success=${success} retryAfter=${retry_after} budgetReached=${time_budget_reached} elapsed=${elapsed_sec}s"

            if [ "${stopped}" = "true" ]; then
              echo "Server manual stop requested. Ending staged process run."
              exit 0
            fi

            if ! [[ "${processed}" =~ ^[0-9]+$ ]]; then
              processed="0"
            fi

            if [ "${success}" != "true" ] && [[ "${retry_after}" =~ ^[0-9]+$ ]] && [ "${retry_after}" -gt 0 ]; then
               echo "Rate limit detected. Note: single-cycle refactor skips inline retries. Will retry on next cron."
               can_continue="false"
               continue
            fi

            if [ "${time_budget_reached}" = "true" ]; then
               echo "Step ${step} reached time budget. Not fully drained. Next steps will be skipped."
               can_continue="false"
            else
               if [ "${processed}" -gt 0 ]; then
                 echo "Step ${step} completely drained (${processed} items processed)."
               else
                 echo "Step ${step} already empty (0 items processed)."
               fi
            fi

          done
        env:
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
          PAID_OPENAI_API_KEY: ${{ secrets.PAID_OPENAI_API_KEY }}
          PAID_ANTHROPIC_API_KEY: ${{ secrets.PAID_ANTHROPIC_API_KEY }}
          PAID_GOOGLE_API_KEY: ${{ secrets.PAID_GOOGLE_API_KEY }}
          PROCESS_STEP: ${{ github.event.inputs.process_step || 'all' }}
          MAX_EXECUTION_MS: ${{ github.event.inputs.max_execution_ms || '1440000' }}
